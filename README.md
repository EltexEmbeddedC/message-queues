# Очереди сообщений

## Сборка и запуск

1. Необходимо перейти в корневую директорию и выполнить команду для сборки проекта `make`

2. Исполняемые файлы появятся в папке `bin`

3. Для удаления всех объектных и исполняемых файлов необходимо выполнить команду `make clean`

## Задания

### Задание 1. Реализовать 2 программы: первая сервер, вторая клиент. Сервер создает очередь сообщений и записывает сообщение виде строки `Hi!`, ждет ответа от клиента и выводит на экран, удаляет очередь. Клиент подключается к очереди, считывает сообщение от сервера, выводит на экран, отвечает серверу сообщением в виде строки `Hello!`. Сделать это как для POSIX, так и для SYSTEM V стандартов.

Убедимся, что программа работает, запустив сервер, а затем клиента:

![Обмен приветствиями](/img/task1.gif)

> [!NOTE]
> Результат работы для POSIX и SYSTEM V стандартов будет одинаковый.

### Задание 2. Написать 2 программы: первая сервер, вторая клиент. Сервер создает очередь сообщений для реализации чата с общей комнатой (если необходимо, то можно и больше очередей создать) и его задача уведомлять клиентов о появлении новых участников, о новых сообщениях. Клиент подключается к очереди, созданной сервером, сообщает ему свое имя и получает в ответ все сообщения в комнате. Далее может отправлять сообщения в общий чат. Получение служебных сообщений от сервера (имена новых клиентов, сообщения от других пользователей) и отправка сообщений в чат лучше реализовать в разных потоках. Интерфейс клиента реализуем с помощью библиотеки ncurses.

**Запуск**

1. Запуск сервера: `./t2server`
2. Запуск клиента `./t2client <имя_клиента>` 

**Описание работы**

1. Сервер создает очередь для служебных сообщений;

2. Клиент подключаается к очереди и отправляет запрос на регистрацию;

3. Сервер получает этот запрос, присваивает клиенту id, создает очередь для дальнейшей передачи информации о сообщениях и подключенных клиентах  (эта очередь отдельная для каждого нового клиента) и уведомляет всех подключенных клиентов о новичке;

4. Идентификатор и дескриптор очереди отправляются клиенту;

5. Клиент, получив эту информацию, подключается к собственной очереди и читает сообщения, ранее написанные в чате, а также информацию о подключенных клиентах;

6. Последующие сообщения, отправленные клиентом, будут отправлены серверу и разосланы тем по остальным пользователям;

7. При отключении клиента, сервер уведомляет об этом остальных пользователей;

8. При завершении работы сервера вся динамическая память освобождается, а очереди удаляются.

    >Правильное отключение клиента и сервера перехватывается обработкой сигнала `Ctrl + C`

**Демонстрация работы**

- Запустим сервер, а затем `клиента_1`. `Клиент_1` пишет сообщение в чат. Затем запускается `клиент_2`. Он получает информацию об уже написанных сообщениях и именах всех клиентов, подключенных к чату (это `клиент_1` и `клиент_2`). `Клиенту_1` тем временем приходит информация о подключении `клиента_2`:

    ![Подключение](/img/connection.gif)

    > Сервер тем временем логирует всю информацию.

- Оба клиента обмениваются в чате приветственными сообщениями:

    ![Обмен приветствиями](/img/hello.gif)

- `Клиент_1` отключается от сервера. У `клиента_2` обновляется информация о подключенных пользователях. Отключается `клиент_1`, вручную завершается работа сервера:

    ![Отключение](/img/disconnection.gif)